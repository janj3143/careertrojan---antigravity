"""
Mentorship Service - Backend API for Mentor-User Linking System
Week 1 Implementation - November 15, 2025

Provides:
- Anonymous mentor-user linking (privacy-protected)
- Mentor note management
- Requirement document generation and sign-off
- Invoice creation and fund release tracking
- Mentor application processing
"""

import logging
from typing import Optional, Dict, List, Any
from datetime import datetime, timedelta
import secrets
import hashlib
from pathlib import Path
import json

from services.backend_api.utils.mentor_application_snapshot import build_application_snapshot

logger = logging.getLogger(__name__)


class MentorshipService:
    """Core mentorship service for anonymous linking and operations"""

    def __init__(self, db_connection):
        """
        Initialize mentorship service

        Args:
            db_connection: Database connection object (psycopg2 or similar)
        """
        self.db = db_connection
        logger.info("MentorshipService initialized")

    # ========================================================================
    # MENTOR-USER LINKING (ANONYMOUS)
    # ========================================================================

    def create_mentorship_link(
        self,
        user_id: str,
        mentor_id: str,
        program_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Create anonymous mentor-user link

        Args:
            user_id: Internal user ID
            mentor_id: Internal mentor ID
            program_id: Optional program identifier

        Returns:
            {
                'link_id': 'LINK_12345',
                'anonymous_name': 'Mentee #12345',
                'status': 'pending',
                'created_date': '2025-11-15T10:30:00Z'
            }
        """
        try:
            # Generate unique link ID
            link_id = self._generate_link_id()

            # Anonymous name auto-generated by database trigger
            query = """
                INSERT INTO mentorship_links (link_id, user_id, mentor_id, program_id, status)
                VALUES (%s, %s, %s, %s, 'pending')
                RETURNING link_id, anonymous_name, status, created_date
            """

            cursor = self.db.cursor()
            cursor.execute(query, (link_id, user_id, mentor_id, program_id))
            result = cursor.fetchone()
            self.db.commit()

            logger.info(f"Created mentorship link: {link_id} (Mentor: {mentor_id}, User: {user_id})")

            return {
                'link_id': result[0],
                'anonymous_name': result[1],
                'status': result[2],
                'created_date': result[3].isoformat() if result[3] else None
            }

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating mentorship link: {e}")
            raise

    def get_mentor_connections(
        self,
        mentor_id: str,
        status: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Get all mentorship connections for a mentor

        Args:
            mentor_id: Mentor's ID
            status: Optional filter (active, paused, completed)

        Returns:
            [
                {
                    'link_id': 'LINK_12345',
                    'anonymous_name': 'Mentee #12345',
                    'status': 'active',
                    'created_date': '2025-11-01',
                    'program_id': 'leadership_growth'
                },
                ...
            ]
        """
        try:
            query = """
                SELECT link_id, anonymous_name, status, created_date, program_id, completion_date
                FROM mentorship_links
                WHERE mentor_id = %s
            """
            params = [mentor_id]

            if status:
                query += " AND status = %s"
                params.append(status)

            query += " ORDER BY created_date DESC"

            cursor = self.db.cursor()
            cursor.execute(query, params)
            results = cursor.fetchall()

            connections = []
            for row in results:
                connections.append({
                    'link_id': row[0],
                    'anonymous_name': row[1],
                    'status': row[2],
                    'created_date': row[3].isoformat() if row[3] else None,
                    'program_id': row[4],
                    'completion_date': row[5].isoformat() if row[5] else None
                })

            return connections

        except Exception as e:
            logger.error(f"Error getting mentor connections: {e}")
            raise

    def get_user_connections(
        self,
        user_id: str,
        status: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Get all mentorship connections for a user

        Args:
            user_id: User's ID
            status: Optional filter

        Returns:
            [
                {
                    'link_id': 'LINK_12345',
                    'mentor_id': 'MENTOR_789',  # User CAN see mentor ID
                    'status': 'active',
                    'program_id': 'leadership_growth'
                },
                ...
            ]
        """
        try:
            query = """
                SELECT link_id, mentor_id, status, created_date, program_id, completion_date
                FROM mentorship_links
                WHERE user_id = %s
            """
            params = [user_id]

            if status:
                query += " AND status = %s"
                params.append(status)

            query += " ORDER BY created_date DESC"

            cursor = self.db.cursor()
            cursor.execute(query, params)
            results = cursor.fetchall()

            connections = []
            for row in results:
                connections.append({
                    'link_id': row[0],
                    'mentor_id': row[1],  # User sees mentor ID (not anonymous)
                    'status': row[2],
                    'created_date': row[3].isoformat() if row[3] else None,
                    'program_id': row[4],
                    'completion_date': row[5].isoformat() if row[5] else None
                })

            return connections

        except Exception as e:
            logger.error(f"Error getting user connections: {e}")
            raise

    def update_link_status(
        self,
        link_id: str,
        new_status: str
    ) -> bool:
        """
        Update mentorship link status

        Args:
            link_id: Link identifier
            new_status: active, paused, completed, cancelled

        Returns:
            True if successful
        """
        try:
            query = """
                UPDATE mentorship_links
                SET status = %s,
                    completion_date = CASE WHEN %s = 'completed' THEN NOW() ELSE completion_date END
                WHERE link_id = %s
            """

            cursor = self.db.cursor()
            cursor.execute(query, (new_status, new_status, link_id))
            self.db.commit()

            logger.info(f"Updated link {link_id} status to {new_status}")
            return True

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error updating link status: {e}")
            raise

    # ========================================================================
    # MENTOR NOTES
    # ========================================================================

    def create_note(
        self,
        link_id: str,
        mentor_id: str,
        note_content: str,
        note_type: str = 'session',
        note_title: Optional[str] = None,
        is_shared_with_user: bool = False,
        session_date: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Create mentor note for a mentorship

        Args:
            link_id: Mentorship link
            mentor_id: Mentor creating note
            note_content: Note text
            note_type: session, requirement, progress, observation, ai_generated
            note_title: Optional title
            is_shared_with_user: Can user see this?
            session_date: When was the session (YYYY-MM-DD)

        Returns:
            {'note_id': 123, 'created_date': '2025-11-15...'}
        """
        try:
            query = """
                INSERT INTO mentor_notes
                (link_id, mentor_id, note_type, note_title, note_content, is_shared_with_user, session_date)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
                RETURNING note_id, created_date
            """

            cursor = self.db.cursor()
            cursor.execute(query, (
                link_id, mentor_id, note_type, note_title,
                note_content, is_shared_with_user, session_date
            ))
            result = cursor.fetchone()
            self.db.commit()

            logger.info(f"Created note {result[0]} for link {link_id}")

            return {
                'note_id': result[0],
                'created_date': result[1].isoformat() if result[1] else None
            }

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating note: {e}")
            raise

    def get_notes_for_link(
        self,
        link_id: str,
        viewer_role: str = 'mentor'
    ) -> List[Dict[str, Any]]:
        """
        Get all notes for a mentorship link

        Args:
            link_id: Mentorship link
            viewer_role: 'mentor' or 'user' (users only see shared notes)

        Returns:
            [
                {
                    'note_id': 123,
                    'note_type': 'session',
                    'note_title': 'Session 3 - Leadership Skills',
                    'note_content': '...',
                    'created_date': '2025-11-15',
                    'session_date': '2025-11-14'
                },
                ...
            ]
        """
        try:
            query = """
                SELECT note_id, note_type, note_title, note_content,
                       created_date, updated_date, is_shared_with_user, session_date
                FROM mentor_notes
                WHERE link_id = %s
            """

            # Users only see shared notes
            if viewer_role == 'user':
                query += " AND is_shared_with_user = TRUE"

            query += " ORDER BY created_date DESC"

            cursor = self.db.cursor()
            cursor.execute(query, (link_id,))
            results = cursor.fetchall()

            notes = []
            for row in results:
                notes.append({
                    'note_id': row[0],
                    'note_type': row[1],
                    'note_title': row[2],
                    'note_content': row[3],
                    'created_date': row[4].isoformat() if row[4] else None,
                    'updated_date': row[5].isoformat() if row[5] else None,
                    'is_shared_with_user': row[6],
                    'session_date': row[7].isoformat() if row[7] else None
                })

            return notes

        except Exception as e:
            logger.error(f"Error getting notes: {e}")
            raise

    def update_note(
        self,
        note_id: int,
        note_content: Optional[str] = None,
        note_title: Optional[str] = None,
        is_shared_with_user: Optional[bool] = None
    ) -> bool:
        """
        Update existing note

        Returns:
            True if successful
        """
        try:
            updates = []
            params = []

            if note_content is not None:
                updates.append("note_content = %s")
                params.append(note_content)

            if note_title is not None:
                updates.append("note_title = %s")
                params.append(note_title)

            if is_shared_with_user is not None:
                updates.append("is_shared_with_user = %s")
                params.append(is_shared_with_user)

            if not updates:
                return True

            updates.append("updated_date = NOW()")
            params.append(note_id)

            query = f"""
                UPDATE mentor_notes
                SET {', '.join(updates)}
                WHERE note_id = %s
            """

            cursor = self.db.cursor()
            cursor.execute(query, params)
            self.db.commit()

            logger.info(f"Updated note {note_id}")
            return True

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error updating note: {e}")
            raise

    # ========================================================================
    # REQUIREMENT DOCUMENTS
    # ========================================================================

    def create_requirement_document(
        self,
        link_id: str,
        mentor_id: str,
        user_id: str,
        document_content: str,
        document_title: str = "Mentorship Requirement Document"
    ) -> Dict[str, Any]:
        """
        Create requirement document (AI-generated from session notes)

        Args:
            link_id: Mentorship link
            mentor_id: Mentor ID
            user_id: User ID
            document_content: Markdown content
            document_title: Document title

        Returns:
            {
                'doc_id': 456,
                'status': 'draft',
                'version': 1
            }
        """
        try:
            query = """
                INSERT INTO requirement_documents
                (link_id, mentor_id, user_id, document_title, document_content)
                VALUES (%s, %s, %s, %s, %s)
                RETURNING doc_id, status, version, generated_date
            """

            cursor = self.db.cursor()
            cursor.execute(query, (link_id, mentor_id, user_id, document_title, document_content))
            result = cursor.fetchone()
            self.db.commit()

            logger.info(f"Created requirement document {result[0]} for link {link_id}")

            return {
                'doc_id': result[0],
                'status': result[1],
                'version': result[2],
                'generated_date': result[3].isoformat() if result[3] else None
            }

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating requirement document: {e}")
            raise

    def get_requirement_document(
        self,
        doc_id: int
    ) -> Optional[Dict[str, Any]]:
        """
        Get requirement document by ID

        Returns:
            Full document details including sign-off status
        """
        try:
            query = """
                SELECT doc_id, link_id, mentor_id, user_id, document_title, document_content,
                       generated_date, user_signed_off, user_signoff_date, user_signature,
                       mentor_signed_off, mentor_signoff_date, mentor_signature,
                       version, status, rejection_reason
                FROM requirement_documents
                WHERE doc_id = %s
            """

            cursor = self.db.cursor()
            cursor.execute(query, (doc_id,))
            row = cursor.fetchone()

            if not row:
                return None

            return {
                'doc_id': row[0],
                'link_id': row[1],
                'mentor_id': row[2],
                'user_id': row[3],
                'document_title': row[4],
                'document_content': row[5],
                'generated_date': row[6].isoformat() if row[6] else None,
                'user_signed_off': row[7],
                'user_signoff_date': row[8].isoformat() if row[8] else None,
                'user_signature': row[9],
                'mentor_signed_off': row[10],
                'mentor_signoff_date': row[11].isoformat() if row[11] else None,
                'mentor_signature': row[12],
                'version': row[13],
                'status': row[14],
                'rejection_reason': row[15]
            }

        except Exception as e:
            logger.error(f"Error getting requirement document: {e}")
            raise

    def get_requirement_documents_for_link(self, link_id: str) -> List[Dict[str, Any]]:
        """List all requirement documents for a mentorship link.

        Returns lightweight metadata plus content and sign-off status.
        """
        try:
            query = """
                SELECT doc_id, document_title, document_content,
                       generated_date, version, status,
                       user_signed_off, user_signoff_date,
                       mentor_signed_off, mentor_signoff_date
                FROM requirement_documents
                WHERE link_id = %s
                ORDER BY generated_date DESC, doc_id DESC
            """

            cursor = self.db.cursor()
            cursor.execute(query, (link_id,))
            rows = cursor.fetchall() or []

            documents: List[Dict[str, Any]] = []
            for row in rows:
                documents.append(
                    {
                        "doc_id": row[0],
                        "document_title": row[1],
                        "document_content": row[2],
                        "generated_date": row[3].isoformat() if row[3] else None,
                        "version": row[4],
                        "status": row[5],
                        "user_signed_off": row[6],
                        "user_signoff_date": row[7].isoformat() if row[7] else None,
                        "mentor_signed_off": row[8],
                        "mentor_signoff_date": row[9].isoformat() if row[9] else None,
                    }
                )

            return documents

        except Exception as e:
            logger.error(f"Error getting requirement documents for link {link_id}: {e}")
            raise

    def sign_document(
        self,
        doc_id: int,
        signer_role: str,
        signature: str
    ) -> bool:
        """
        Sign requirement document

        Args:
            doc_id: Document ID
            signer_role: 'user' or 'mentor'
            signature: Digital signature / confirmation text

        Returns:
            True if successful
        """
        try:
            if signer_role == 'user':
                query = """
                    UPDATE requirement_documents
                    SET user_signed_off = TRUE,
                        user_signoff_date = NOW(),
                        user_signature = %s,
                        status = CASE
                            WHEN mentor_signed_off = TRUE THEN 'signed'
                            ELSE 'pending_mentor'
                        END
                    WHERE doc_id = %s
                """
            elif signer_role == 'mentor':
                query = """
                    UPDATE requirement_documents
                    SET mentor_signed_off = TRUE,
                        mentor_signoff_date = NOW(),
                        mentor_signature = %s,
                        status = CASE
                            WHEN user_signed_off = TRUE THEN 'signed'
                            ELSE 'pending_user'
                        END
                    WHERE doc_id = %s
                """
            else:
                raise ValueError("signer_role must be 'user' or 'mentor'")

            cursor = self.db.cursor()
            cursor.execute(query, (signature, doc_id))
            self.db.commit()

            logger.info(f"Document {doc_id} signed by {signer_role}")
            return True

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error signing document: {e}")
            raise

    def reject_document(
        self,
        doc_id: int,
        rejection_reason: str
    ) -> bool:
        """
        Reject requirement document (needs revision)

        Args:
            doc_id: Document ID
            rejection_reason: Why rejected

        Returns:
            True if successful
        """
        try:
            query = """
                UPDATE requirement_documents
                SET status = 'rejected',
                    rejection_reason = %s
                WHERE doc_id = %s
            """

            cursor = self.db.cursor()
            cursor.execute(query, (rejection_reason, doc_id))
            self.db.commit()

            logger.info(f"Document {doc_id} rejected")
            return True

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error rejecting document: {e}")
            raise

    # ========================================================================
    # INVOICING & PAYMENTS
    # ========================================================================

    def create_invoice(
        self,
        link_id: str,
        mentor_id: str,
        user_id: str,
        amount: float,
        service_description: str,
        currency: str = 'USD'
    ) -> Dict[str, Any]:
        """
        Create invoice for mentorship service

        Args:
            link_id: Mentorship link
            mentor_id: Mentor ID
            user_id: User ID
            amount: Total amount (platform fee and mentor portion auto-calculated)
            service_description: What is being charged for
            currency: ISO 4217 code (USD, GBP, EUR, etc.)

        Returns:
            {
                'invoice_id': 789,
                'invoice_number': 'INV-2025-11-00789',
                'amount': 150.00,
                'currency': 'USD',
                'platform_fee': 30.00,  # 20%
                'mentor_portion': 120.00,  # 80%
                'status': 'pending'
            }
        """
        try:
            # Generate invoice number
            invoice_number = self._generate_invoice_number()

            query = """
                INSERT INTO invoices
                (link_id, mentor_id, user_id, invoice_number, service_description, amount, currency)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
                RETURNING invoice_id, invoice_number, amount, currency, platform_fee, mentor_portion, status
            """

            cursor = self.db.cursor()
            cursor.execute(query, (link_id, mentor_id, user_id, invoice_number, service_description, amount, currency))
            result = cursor.fetchone()
            self.db.commit()

            logger.info(f"Created invoice {result[1]} for {currency} {amount}")

            return {
                'invoice_id': result[0],
                'invoice_number': result[1],
                'amount': float(result[2]),
                'currency': result[3],
                'platform_fee': float(result[4]),
                'mentor_portion': float(result[5]),
                'status': result[6]
            }

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating invoice: {e}")
            raise

    def get_mentor_invoices(
        self,
        mentor_id: str,
        status: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Get all invoices for a mentor

        Args:
            mentor_id: Mentor ID
            status: Optional filter (pending, paid, held, released, disputed)

        Returns:
            List of invoices
        """
        try:
            query = """
                SELECT invoice_id, invoice_number, link_id, service_description,
                       amount, platform_fee, mentor_portion, status,
                       created_date, paid_date, released_date
                FROM invoices
                WHERE mentor_id = %s
            """
            params = [mentor_id]

            if status:
                query += " AND status = %s"
                params.append(status)

            query += " ORDER BY created_date DESC"

            cursor = self.db.cursor()
            cursor.execute(query, params)
            results = cursor.fetchall()

            invoices = []
            for row in results:
                invoices.append({
                    'invoice_id': row[0],
                    'invoice_number': row[1],
                    'link_id': row[2],
                    'service_description': row[3],
                    'amount': float(row[4]),
                    'platform_fee': float(row[5]),
                    'mentor_portion': float(row[6]),
                    'status': row[7],
                    'created_date': row[8].isoformat() if row[8] else None,
                    'paid_date': row[9].isoformat() if row[9] else None,
                    'released_date': row[10].isoformat() if row[10] else None
                })

            return invoices

        except Exception as e:
            logger.error(f"Error getting mentor invoices: {e}")
            raise

    def mark_invoice_paid(
        self,
        invoice_id: int,
        stripe_payment_intent_id: str,
        stripe_charge_id: str
    ) -> bool:
        """
        Mark invoice as paid (user paid platform)

        Args:
            invoice_id: Invoice ID
            stripe_payment_intent_id: Stripe payment intent
            stripe_charge_id: Stripe charge ID

        Returns:
            True if successful
        """
        try:
            query = """
                UPDATE invoices
                SET status = 'held',
                    paid_date = NOW(),
                    stripe_payment_intent_id = %s,
                    stripe_charge_id = %s
                WHERE invoice_id = %s
            """

            cursor = self.db.cursor()
            cursor.execute(query, (stripe_payment_intent_id, stripe_charge_id, invoice_id))
            self.db.commit()

            # Create fund release record
            release_query = """
                INSERT INTO fund_releases (invoice_id, link_id)
                SELECT invoice_id, link_id FROM invoices WHERE invoice_id = %s
            """
            cursor.execute(release_query, (invoice_id,))
            self.db.commit()

            logger.info(f"Invoice {invoice_id} marked as paid, funds held")
            return True

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error marking invoice paid: {e}")
            raise

    def mark_service_delivered(
        self,
        invoice_id: int,
        mentor_id: str
    ) -> bool:
        """
        Mentor marks service as delivered

        Args:
            invoice_id: Invoice ID
            mentor_id: Mentor ID (for verification)

        Returns:
            True if successful
        """
        try:
            query = """
                UPDATE fund_releases
                SET mentor_delivered = TRUE,
                    mentor_delivery_date = NOW()
                WHERE invoice_id = %s
                AND EXISTS (
                    SELECT 1 FROM invoices
                    WHERE invoice_id = %s AND mentor_id = %s
                )
            """

            cursor = self.db.cursor()
            cursor.execute(query, (invoice_id, invoice_id, mentor_id))
            self.db.commit()

            logger.info(f"Mentor marked service delivered for invoice {invoice_id}")
            return True

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error marking service delivered: {e}")
            raise

    def confirm_service_completion(
        self,
        invoice_id: int,
        user_id: str
    ) -> bool:
        """
        User confirms satisfaction with service

        Args:
            invoice_id: Invoice ID
            user_id: User ID (for verification)

        Returns:
            True if successful, triggers fund release if both confirmed
        """
        try:
            query = """
                UPDATE fund_releases
                SET user_confirmed = TRUE,
                    user_confirmation_date = NOW()
                WHERE invoice_id = %s
                AND EXISTS (
                    SELECT 1 FROM invoices
                    WHERE invoice_id = %s AND user_id = %s
                )
            """

            cursor = self.db.cursor()
            cursor.execute(query, (invoice_id, invoice_id, user_id))
            self.db.commit()

            # Check if both parties confirmed â†’ release funds
            check_query = """
                SELECT mentor_delivered, user_confirmed
                FROM fund_releases
                WHERE invoice_id = %s
            """
            cursor.execute(check_query, (invoice_id,))
            result = cursor.fetchone()

            if result and result[0] and result[1]:  # Both confirmed
                self._release_funds(invoice_id)

            logger.info(f"User confirmed completion for invoice {invoice_id}")
            return True

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error confirming service completion: {e}")
            raise

    def _release_funds(self, invoice_id: int):
        """
        Internal: Release funds to mentor (both parties confirmed)

        Args:
            invoice_id: Invoice ID
        """
        try:
            # Update invoice status
            query = """
                UPDATE invoices
                SET status = 'released',
                    released_date = NOW()
                WHERE invoice_id = %s
            """
            cursor = self.db.cursor()
            cursor.execute(query, (invoice_id,))

            # Update fund release
            release_query = """
                UPDATE fund_releases
                SET release_date = NOW()
                WHERE invoice_id = %s
            """
            cursor.execute(release_query, (invoice_id,))
            self.db.commit()

            logger.info(f"Funds released for invoice {invoice_id}")

            # TODO: Integrate with Stripe payout to mentor
            # stripe.Payout.create(...)

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error releasing funds: {e}")
            raise

    def raise_dispute(
        self,
        invoice_id: int,
        dispute_description: str
    ) -> bool:
        """
        Raise dispute on invoice (either party can do this)

        Args:
            invoice_id: Invoice ID
            dispute_description: Why dispute is raised

        Returns:
            True if successful
        """
        try:
            query = """
                UPDATE fund_releases
                SET dispute_raised = TRUE,
                    dispute_date = NOW(),
                    dispute_description = %s
                WHERE invoice_id = %s
            """

            cursor = self.db.cursor()
            cursor.execute(query, (dispute_description, invoice_id))

            # Update invoice status
            invoice_query = """
                UPDATE invoices
                SET status = 'disputed'
                WHERE invoice_id = %s
            """
            cursor.execute(invoice_query, (invoice_id,))
            self.db.commit()

            logger.warning(f"Dispute raised for invoice {invoice_id}")
            return True

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error raising dispute: {e}")
            raise

    # ========================================================================
    # MENTOR APPLICATIONS
    # ========================================================================

    def submit_mentor_application(
        self,
        applicant_user_id: str,
        email: str,
        full_name: str,
        application_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Submit mentor application

        Args:
            applicant_user_id: User ID applying
            email: Email
            full_name: Full name
            application_data: Dict containing all form fields

        Returns:
            {'application_id': 123, 'status': 'submitted'}
        """
        try:
            insert_query = """
                INSERT INTO mentor_applications
                (applicant_user_id, email, full_name, phone, linkedin_url,
                 industry, specialization, years_experience, current_role, current_company,
                 expertise_areas, target_audience, session_formats, hours_per_week, initial_packages,
                 ai_focus_tags, ai_chat_history, source)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                RETURNING application_id, status, submitted_date
            """

            cursor = self.db.cursor()
            cursor.execute(insert_query, (
                applicant_user_id,
                email,
                full_name,
                application_data.get('phone'),
                application_data.get('linkedin_url'),
                application_data.get('industry'),
                application_data.get('specialization'),
                application_data.get('years_experience'),
                application_data.get('current_role'),
                application_data.get('current_company'),
                json.dumps(application_data.get('expertise_areas', [])),
                json.dumps(application_data.get('target_audience', [])),
                json.dumps(application_data.get('session_formats', [])),
                application_data.get('hours_per_week'),
                json.dumps(application_data.get('initial_packages', [])),
                json.dumps(application_data.get('ai_recommendations', [])),
                json.dumps(application_data.get('ai_chat_history', [])),
                application_data.get('source', 'user_portal')
            ))
            result = cursor.fetchone()

            step1_payload = application_data.get('step1') or {
                'full_name': full_name,
                'email': email,
                'phone': application_data.get('phone'),
                'linkedin_url': application_data.get('linkedin_url'),
                'industry': application_data.get('industry'),
                'specialization': application_data.get('specialization'),
                'years_experience': application_data.get('years_experience'),
                'current_role': application_data.get('current_role'),
                'current_company': application_data.get('current_company')
            }

            step2_payload = application_data.get('step2') or {
                'expertise_areas': application_data.get('expertise_areas', []),
                'expertise_other': application_data.get('expertise_other'),
                'target_audience': application_data.get('target_audience', []),
                'session_formats': application_data.get('session_formats', []),
                'hours_per_week': application_data.get('hours_per_week'),
                'ai_recommendations': application_data.get('ai_recommendations', [])
            }

            step3_payload = application_data.get('step3') or {
                'packages': application_data.get('initial_packages', [])
            }

            snapshot = build_application_snapshot(
                application_id=str(result[0]),
                status=result[1],
                submitted_date=result[2],
                step1=step1_payload,
                step2=step2_payload,
                step3=step3_payload,
                ai_chat_history=application_data.get('ai_chat_history', [])
            )

            snapshot_query = """
                UPDATE mentor_applications
                SET application_snapshot = %s
                WHERE application_id = %s
            """
            cursor.execute(snapshot_query, (json.dumps(snapshot), result[0]))
            self.db.commit()

            logger.info(f"Mentor application submitted: {result[0]}")

            return {
                'application_id': result[0],
                'status': result[1],
                'submitted_date': result[2].isoformat() if result[2] else None
            }

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error submitting mentor application: {e}")
            raise

    def get_pending_applications(self) -> List[Dict[str, Any]]:
        """
        Get all pending mentor applications for Guardian review

        Returns:
            List of applications
        """
        try:
            query = """
                SELECT application_id, applicant_user_id, email, full_name,
                       phone, linkedin_url, industry, specialization, years_experience,
                       current_role, current_company,
                       expertise_areas, target_audience, session_formats, hours_per_week,
                       initial_packages, ai_focus_tags, ai_chat_history, application_snapshot,
                       submitted_date, status
                FROM mentor_applications
                WHERE status IN ('submitted', 'under_review')
                ORDER BY submitted_date ASC
            """

            cursor = self.db.cursor()
            cursor.execute(query)
            results = cursor.fetchall()

            applications: List[Dict[str, Any]] = []
            for row in results:
                (
                    application_id, applicant_user_id, email, full_name,
                    phone, linkedin_url, industry, specialization, years_experience,
                    current_role, current_company,
                    expertise_areas, target_audience, session_formats, hours_per_week,
                    initial_packages, ai_focus_tags, ai_chat_history, application_snapshot,
                    submitted_date, status
                ) = row

                snapshot_data = None
                if application_snapshot:
                    snapshot_data = application_snapshot if isinstance(application_snapshot, dict) else json.loads(application_snapshot)

                if not snapshot_data:
                    step1_payload = {
                        'full_name': full_name,
                        'email': email,
                        'phone': phone,
                        'linkedin_url': linkedin_url,
                        'industry': industry,
                        'specialization': specialization,
                        'years_experience': years_experience,
                        'current_role': current_role,
                        'current_company': current_company
                    }
                    step2_payload = {
                        'expertise_areas': expertise_areas if isinstance(expertise_areas, list) else json.loads(expertise_areas or '[]'),
                        'target_audience': target_audience if isinstance(target_audience, list) else json.loads(target_audience or '[]'),
                        'session_formats': session_formats if isinstance(session_formats, list) else json.loads(session_formats or '[]'),
                        'hours_per_week': hours_per_week,
                        'ai_recommendations': ai_focus_tags if isinstance(ai_focus_tags, list) else json.loads(ai_focus_tags or '[]')
                    }
                    step3_payload = {
                        'packages': initial_packages if isinstance(initial_packages, list) else json.loads(initial_packages or '[]')
                    }
                    chat_history_payload = ai_chat_history if isinstance(ai_chat_history, list) else json.loads(ai_chat_history or '[]')

                    snapshot_data = build_application_snapshot(
                        application_id=str(application_id),
                        status=status,
                        submitted_date=submitted_date,
                        step1=step1_payload,
                        step2=step2_payload,
                        step3=step3_payload,
                        ai_chat_history=chat_history_payload,
                        source='database'
                    )
                else:
                    # Ensure status/timestamps stay in sync with DB state
                    snapshot_data['application_id'] = str(application_id)
                    snapshot_data['status'] = status
                    snapshot_data['submitted_date'] = submitted_date.isoformat() if submitted_date else snapshot_data.get('submitted_date')
                    if ai_focus_tags and not snapshot_data.get('expertise', {}).get('ai_recommendations'):
                        recommendations = ai_focus_tags if isinstance(ai_focus_tags, list) else json.loads(ai_focus_tags or '[]')
                        snapshot_data.setdefault('expertise', {})['ai_recommendations'] = recommendations
                    if ai_chat_history and not snapshot_data.get('ai_chat_history'):
                        snapshot_data['ai_chat_history'] = ai_chat_history if isinstance(ai_chat_history, list) else json.loads(ai_chat_history or '[]')

                applications.append(snapshot_data)

            return applications

        except Exception as e:
            logger.error(f"Error getting pending applications: {e}")
            raise

    def approve_mentor_application(
        self,
        application_id: int,
        reviewer_admin_id: str,
        mentor_id: str
    ) -> bool:
        """
        Approve mentor application

        Args:
            application_id: Application ID
            reviewer_admin_id: Guardian who approved
            mentor_id: Assigned mentor ID

        Returns:
            True if successful
        """
        try:
            query = """
                UPDATE mentor_applications
                SET status = 'approved',
                    reviewed_date = NOW(),
                    reviewer_admin_id = %s,
                    mentor_id = %s,
                    activated_date = NOW()
                WHERE application_id = %s
            """

            cursor = self.db.cursor()
            cursor.execute(query, (reviewer_admin_id, mentor_id, application_id))
            self.db.commit()

            logger.info(f"Approved mentor application {application_id}, assigned ID: {mentor_id}")
            return True

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error approving application: {e}")
            raise

    # ========================================================================
    # MENTOR PAYOUT DETAILS (BANK TRANSFER)
    # ========================================================================

    def save_payout_details(
        self,
        mentor_id: str,
        payout_data: Dict[str, Any]
    ) -> bool:
        """
        Save or update mentor's payout details (bank account)

        Args:
            mentor_id: Mentor ID
            payout_data: Dict containing bank account details

        Returns:
            True if successful
        """
        try:
            # Check if details already exist
            check_query = "SELECT payout_id FROM mentor_payout_details WHERE mentor_id = %s"
            cursor = self.db.cursor()
            cursor.execute(check_query, (mentor_id,))
            existing = cursor.fetchone()

            if existing:
                # Update existing
                query = """
                    UPDATE mentor_payout_details
                    SET account_holder_name = %s,
                        bank_name = %s,
                        account_number = %s,
                        routing_number = %s,
                        swift_code = %s,
                        iban = %s,
                        sort_code = %s,
                        billing_address = %s,
                        city = %s,
                        state_province = %s,
                        postal_code = %s,
                        country = %s,
                        preferred_currency = %s,
                        payout_method = %s,
                        payout_email = %s,
                        updated_date = NOW(),
                        verified = FALSE
                    WHERE mentor_id = %s
                """
            else:
                # Insert new
                query = """
                    INSERT INTO mentor_payout_details
                    (mentor_id, account_holder_name, bank_name, account_number, routing_number,
                     swift_code, iban, sort_code, billing_address, city, state_province,
                     postal_code, country, preferred_currency, payout_method, payout_email)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """

            params = (
                payout_data.get('account_holder_name'),
                payout_data.get('bank_name'),
                payout_data.get('account_number'),
                payout_data.get('routing_number'),
                payout_data.get('swift_code'),
                payout_data.get('iban'),
                payout_data.get('sort_code'),
                payout_data.get('billing_address'),
                payout_data.get('city'),
                payout_data.get('state_province'),
                payout_data.get('postal_code'),
                payout_data.get('country'),
                payout_data.get('preferred_currency', 'USD'),
                payout_data.get('payout_method', 'bank_transfer'),
                payout_data.get('payout_email'),
                mentor_id
            ) if not existing else (
                payout_data.get('account_holder_name'),
                payout_data.get('bank_name'),
                payout_data.get('account_number'),
                payout_data.get('routing_number'),
                payout_data.get('swift_code'),
                payout_data.get('iban'),
                payout_data.get('sort_code'),
                payout_data.get('billing_address'),
                payout_data.get('city'),
                payout_data.get('state_province'),
                payout_data.get('postal_code'),
                payout_data.get('country'),
                payout_data.get('preferred_currency', 'USD'),
                payout_data.get('payout_method', 'bank_transfer'),
                payout_data.get('payout_email'),
                mentor_id
            )

            cursor.execute(query, params)
            self.db.commit()

            logger.info(f"Saved payout details for mentor {mentor_id}")
            return True

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error saving payout details: {e}")
            raise

    def get_payout_details(
        self,
        mentor_id: str
    ) -> Optional[Dict[str, Any]]:
        """
        Get mentor's payout details

        Args:
            mentor_id: Mentor ID

        Returns:
            Payout details dict or None
        """
        try:
            query = """
                SELECT payout_id, account_holder_name, bank_name, account_number,
                       routing_number, swift_code, iban, sort_code, billing_address,
                       city, state_province, postal_code, country, preferred_currency,
                       payout_method, payout_email, verified, verified_date
                FROM mentor_payout_details
                WHERE mentor_id = %s
            """

            cursor = self.db.cursor()
            cursor.execute(query, (mentor_id,))
            row = cursor.fetchone()

            if not row:
                return None

            return {
                'payout_id': row[0],
                'account_holder_name': row[1],
                'bank_name': row[2],
                'account_number': row[3][-4:] if row[3] else None,  # Mask account number
                'routing_number': row[4],
                'swift_code': row[5],
                'iban': row[6][-4:] if row[6] else None,  # Mask IBAN
                'sort_code': row[7],
                'billing_address': row[8],
                'city': row[9],
                'state_province': row[10],
                'postal_code': row[11],
                'country': row[12],
                'preferred_currency': row[13],
                'payout_method': row[14],
                'payout_email': row[15],
                'verified': row[16],
                'verified_date': row[17].isoformat() if row[17] else None
            }

        except Exception as e:
            logger.error(f"Error getting payout details: {e}")
            raise

    def verify_payout_details(
        self,
        mentor_id: str,
        admin_id: str
    ) -> bool:
        """
        Admin verifies mentor's payout details

        Args:
            mentor_id: Mentor ID
            admin_id: Admin who verified

        Returns:
            True if successful
        """
        try:
            query = """
                UPDATE mentor_payout_details
                SET verified = TRUE,
                    verified_date = NOW(),
                    verified_by_admin_id = %s
                WHERE mentor_id = %s
            """

            cursor = self.db.cursor()
            cursor.execute(query, (admin_id, mentor_id))
            self.db.commit()

            logger.info(f"Verified payout details for mentor {mentor_id} by admin {admin_id}")
            return True

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error verifying payout details: {e}")
            raise

    def initiate_payout(
        self,
        mentor_id: str,
        invoice_id: int,
        admin_id: str
    ) -> Dict[str, Any]:
        """
        Initiate payout to mentor (admin action after fund release)

        Args:
            mentor_id: Mentor ID
            invoice_id: Invoice being paid out
            admin_id: Admin initiating payout

        Returns:
            Transaction details
        """
        try:
            # Get invoice details
            invoice_query = """
                SELECT mentor_portion, currency, status
                FROM invoices
                WHERE invoice_id = %s AND mentor_id = %s
            """
            cursor = self.db.cursor()
            cursor.execute(invoice_query, (invoice_id, mentor_id))
            invoice = cursor.fetchone()

            if not invoice:
                raise ValueError("Invoice not found or mentor mismatch")

            if invoice[2] != 'released':
                raise ValueError("Funds not yet released for this invoice")

            amount = invoice[0]
            currency = invoice[1]

            # Get payout details
            payout_details = self.get_payout_details(mentor_id)
            if not payout_details:
                raise ValueError("No payout details on file for mentor")

            if not payout_details['verified']:
                raise ValueError("Payout details not verified by admin")

            # Create payout transaction record
            query = """
                INSERT INTO payout_transactions
                (mentor_id, invoice_id, amount, currency, payout_method, initiated_by_admin_id)
                VALUES (%s, %s, %s, %s, %s, %s)
                RETURNING transaction_id, status, initiated_date
            """

            cursor.execute(query, (
                mentor_id,
                invoice_id,
                amount,
                currency,
                payout_details['payout_method'],
                admin_id
            ))
            result = cursor.fetchone()
            self.db.commit()

            logger.info(f"Initiated payout transaction {result[0]} for mentor {mentor_id}")

            # TODO: Integrate with actual payment provider (Stripe, Wise, PayPal)
            # This would trigger the bank transfer in production

            return {
                'transaction_id': result[0],
                'amount': float(amount),
                'currency': currency,
                'payout_method': payout_details['payout_method'],
                'status': result[1],
                'initiated_date': result[2].isoformat() if result[2] else None
            }

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error initiating payout: {e}")
            raise

    # ========================================================================
    # HELPER METHODS
    # ========================================================================

    def _generate_link_id(self) -> str:
        """Generate unique link ID (e.g. LINK_12345)"""
        # Get current count
        cursor = self.db.cursor()
        cursor.execute("SELECT COUNT(*) FROM mentorship_links")
        count = cursor.fetchone()[0]

        # Sequential numbering
        return f"LINK_{count + 1:05d}"

    def _generate_invoice_number(self) -> str:
        """Generate unique invoice number (e.g. INV-2025-11-00123)"""
        now = datetime.now()

        cursor = self.db.cursor()
        cursor.execute("SELECT COUNT(*) FROM invoices")
        count = cursor.fetchone()[0]

        return f"INV-{now.year}-{now.month:02d}-{count + 1:05d}"

    # ========================================================================
    # GUARDIAN FEEDBACK
    # ========================================================================

    def get_guardian_feedback(self, mentor_id: str) -> List[Dict[str, Any]]:
        """
        Retrieve feedback from guardians for a specific mentor.
        """
        try:
            # Check if table exists first to avoid hard crash during migration
            cursor = self.db.cursor()
            cursor.execute("""
                SELECT EXISTS (
                    SELECT FROM information_schema.tables 
                    WHERE table_name = 'guardian_feedback'
                );
            """)
            if not cursor.fetchone()[0]:
                return []

            query = """
                SELECT 
                    f.feedback_id,
                    f.link_id,
                    f.rating,
                    f.comments,
                    f.created_at,
                    l.anonymous_name,
                    l.program_id
                FROM guardian_feedback f
                JOIN mentorship_links l ON f.link_id = l.link_id
                WHERE l.mentor_id = %s
                ORDER BY f.created_at DESC
            """
            cursor.execute(query, (mentor_id,))
            results = cursor.fetchall()
            
            feedback = []
            for row in results:
                feedback.append({
                    "id": row[0],
                    "link_id": row[1],
                    "rating": row[2],
                    "comments": row[3],
                    "date": row[4].isoformat() if row[4] else None,
                    "mentee_name": row[5],
                    "program_id": row[6]
                })
            return feedback
        except Exception as e:
            logger.error(f"Error retrieving guardian feedback: {e}")
            return []

